---
date: 2016-10-27T15:24:20+08:00
status: draft
title: 单例模式2
tags: ["设计模式"]
categories: ["正经的"]
---

### 著名的双检锁技术（Double-Check Locking）
讲到单例模式就不得不提双检锁技术。
之所以出名并不是因为这个技术非常牛逼，而是因为它曾经是人们热烈讨论的话题。
该技术曾经在java中大量使用，结果后来被发现是有问题的。
### 贴段代码
既然曾经是在java中大量使用，那就贴段java代码来看个究竟吧。
```java
public class Singleton {
	private static Singleton uniqueInstance;
    
	private Singleton() {
        //初始化的代码
	}
    
	public static Singleton getInstance() {
	   //问题之处也在此：JVM这时会将uniqueInstance写入CPU寄存器
		if (uniqueInstance == null) {
            //锁了该类型对象
			synchronized (Singleton.class) {
			     //假设有多个线程同时调用getInstance方法
			     //当第二个线程执行到这边的时候，uniqueInstance实例已经由第一个线程创建好
			     //但是JVM会从CPU寄存器中取值，造成该判断为true，第二个线程仍然会再创建实例
				if (uniqueInstance == null) {
					uniqueInstance = new Singleton();
				}
			}
		}
		return uniqueInstance;
	}
}
```
### C#中的情况
在CLR（扯到一个不得了的概念，这边就先不深究）中，对任何锁方法的调用都构成了一个完整的内存栅栏，在栅栏之前写入的任何变量都必须在栅栏之前完成；在栅栏之后的任何变量读取都必须在栅栏之后开始。（书上抄过来的话就是这么不好理解）
总之在这边就可以这么理解：在lock之后（差不多就是java中的synchronized），uniqueInstance字段的值必须重新去内存中读取，CPU寄存器里面的东西做不了数。
听他这么一忽悠好像C#这么实现就没什么问题了，结果吹了半天还有另外一个问题。