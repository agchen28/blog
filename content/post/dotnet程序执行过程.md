---
date: 2017-02-23T11:05:53+08:00
draft: false
tags: ["dotnet"]
categories: ["技术相关"]
title: dotnet程序执行过程
---
### 码几行代码
```csharp
    internal class Employee
    {
        public Int32 GetYearsEmployed() {...}

        public virtual String GetProgressReport() {...}

        public static Employee Lookup(String name) {...}
    }

    internal class Manager : Employee
    {
        public override string GetProgressReport() {...}
    }
```
```csharp
        void M3()
        {
            Employee e;
            Int32 year;
            e = new Manager();
            e = Employee.Lookup("joe");
            year = e.GetYearsEmployed();
            e.GetProgressReport();
        }
```

## 执行过程
### 初始化：  
启动Windows进程，加载CLR，初始化托管堆，创建一个线程并分配1M的线程栈。（如下图：左侧矩形为线程栈，顶部灰色部分加三个点表示已经执行过一些代码。右侧一大坨表示托管堆，M3方法未执行前可能会有其他对象，我们暂且不管。）
<img src="/imgs/zxgc/zxgc1.png" width = "662" height = "521" align=center />

### 调用M3方法：  
调用M3方法的时候，CLR会在托管堆上创建M3方法中所需要的类型对象。在这里我们用到Employee，Manager，Int32和String。但Int32和String是常用类型，我们假定它们已经在其他方法中创建了。
<img src="/imgs/zxgc/zxgc2.png" width = "662" height = "521" align=center />  
关于类型对象：  
类型对象就是运行时用来表示该类型的一个对象，这个对象包含一些静态字段。  
可以结合实例对象来理解类型对象，实例对象是我们通过调用构造函数创建的对象，类型对象则是CLR自动调用静态构造函数创建的对象（换句话说，我们平时写的静态构造函数就是用来构造这个类型对象的），在一个托管堆中每个类型只有唯一一个类型对象。

- 类型对象指针。每个托管堆上的对象都有的东西。  
实例对象的类型对象指针会指到它对应的类型对象上。  
类型对象的类型对象指针会指到System.Type类型对象上（这是一个特殊的类型对象，Type类型对象的类型对象指针会指向本身）。  
System.Object的GetType方法就是返回存储在指定对象的类型对象指针中的地址。

- 同步块索引。也是每个托管堆上的对象都有的东西。  
提供给我们最常用的、最大名鼎鼎、地位最高、资格最老的混合线程同步构造--Monitor。可能大家对Monitor不太熟，但是它就是我们常写的lock。  
由这两个方面就可以看出Monitor地位有多高，每个托管堆上的对象都要给它预留一个空间（不管有没有用到），C#编译器还为它准备了专属的关键字lock。  
关于Monitor如何利用同步块索引同步线程以后讲锁的时候再仔细讨论。

- 静态字段。这个应该就不用过多解释了，现在应该可以明白为什么每个实例对象访问的静态数据都是同一份了。

- 方法表。  
包含该类型定义的每个方法的entry。（静态方法和实例方法都在这里面，实例方法与静态方法的区别在于实例方法的调用需要把调用者的引用传进去，也就是方法内部的this）  
每个方法的entry都有一个地址，通过该地址能找到方法的实现。  
方法的首次调用会比较特殊，涉及到JIT编译。  
简单说明下，方法首次调用，JITCompiler函数会被调用，将方法的IL代码编译成CPU指令（JIT编译器还会根据当前运行环境进行优化）。把编译完的CPU指令存储在动态分配的内存中，最后修改被调用方法的entry，修改最初对JITCompiler的引用，使其指向刚存储CPU指令内存块地址。

- 引用基类型的字段。图中没有表示出来。

### 执行M3中的代码：
<img src="/imgs/zxgc/zxgc3.png" width = "800" height = "521" align=center />  

- 定义局部变量  
所有在方法内部定义的变量都会被压入线程栈中。  
CLR自动将所有局部变量初始化为null或0。  
这边要注意一点，如果试图访问未显示初始化的局部变量，C#会报告错误消息：使用了未赋值的局部变量。

- 构造Manager对象  
实例对象中也包含类型对象指针和同步块索引，当然还包括实例字段。  
实例字段除了包含该类定义的还包含任何基类所定义的所有实例字段。  
该实例对象的类型对象指针指向Manager类型对象。

- 调用静态方法  
CLR会定位与定义静态方法的类型对应的类型对象。  
JIT编译器在类型对象的方法表中查找与被调用方法对应的entry，对方法进行JIT编译（如果是首次调用），最后调用JIT编译好的代码。

- 调用非虚实例方法  
JIT编译器会找到e变量的类型所对应的类型对象（本例中就是Employee类型对象）。
如果Employee类型没有定义该方法，就会回溯类层次结构（一直到Object），在沿途的每个类型中查找该方法。  
之所以能够这样做，是因为每个类型对象都有一个字段引用了它的基类型。

- 调用虚实例方法  
JIT编译器会在方法中生成一些额外的代码，方法每次调用都会执行这些代码。  
代码检查对象内部的类型对象指针，该成员指向对象的实际类型，然后调用实际类型所定义的方法。
本例中e引用了一个Manager对象，所以会调用Manager的GetProgressReport方法。

### 方法执行完毕
方法执行完毕，该方法内部所占用的线程栈空间会被弹出，托管堆上没有被引用到的对象会在下一次垃圾回收器回收的时候被释放掉（关于垃圾回收器的工作方式还要另外详细说明）。  
类型对象不会被回收（这个是我猜的，书上好像没有明确的说明），类型对象只有在第一次使用到该类型的时候才进行一次也是唯一一次构造。