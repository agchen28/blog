---
date: 2017-04-27T11:33:01+08:00
draft: false
tags: [".NET","Java"]
categories: ["技术相关"]
title: 泛型
---
许多原因促成了泛型的出现，最引人注目的一个原因就是为了创建容器类，利用泛型就可以指定容器内要持有什么样的对象。  
泛型就是参数化的类型，使代码可以应用于多种类型。  

### Java中的泛型

Java SE5引入了泛型。  
了解一下Java是如何实现泛型的，以及为何采用这种设计方案。

#### 实现方案
看个例子：
```java
public class Test {
    public static void main(String[] args) {
        Class c1 = new ArrayList<Integer>().getClass();
        Class c2 = new ArrayList<String>().getClass();
        System.out.println(c1 == c2);//true
        System.out.println(c1.toString());//class java.util.ArrayList
        System.out.println(c2.toString());//class java.util.ArrayList
    }
}
```
我们会发现ArrayList&lt;Integer&gt;和ArrayList&lt;String&gt;在运行时被认为是相同的类型，事实上它们在运行时就是相同的类型。  
Java采用擦除来实现泛型。  
ArrayList&lt;Integer&gt;和ArrayList&lt;String&gt;这两种形式都被擦除成它们的“原生”类型，即ArrayList。  
Java泛型的核心概念：告诉编译器想使用什么类型，然后编译器帮你处理一切细节。  
就个人愚见，Java的泛型概念只存在于Java编译器，它令我们有使用泛型的感觉，对于运行时来说它根本不知道泛型是什么鬼东西。

#### 采用这种设计方案的原因
因为泛型不是在Java语言出现就有的组成部分，所以把泛型加入到Java中需要考虑一些兼容性问题。  
Java泛型不仅必须支持向后兼容性，而且还要支持“迁移兼容性”。为了不破坏现有类库的情况下将泛型融入Java语言，Java的设计者们和从事此问题相关工作的各个团队决策认为擦除是唯一可行的解决方案。这是一种折中的不得已而为之的实现方案。  
“迁移兼容性”：  
要使得泛化的客户端可以用非泛化的类库来使用，反之亦然，这被称为“迁移兼容性”。

### .NET中的泛型
来看一下.NET中如何实现泛型。  
泛型也不是.NET一出现就有的，在CLR2.0中被加入。  

#### 开放类型与封闭类型
我们知道，CLR会为应用程序使用到的各种类型在托管堆上创建所谓的类型对象。  
具有泛型参数的类型也是类型，同样会有自己的类型对象。

- 开放类型  
具有泛型类型参数的类型称为开放类型，CLR禁止构造开放类型的任何实例。这类似与禁止构造接口类型的实例。（即使通过反射也没办法）

- 封闭类型  
为所有类型参数都传递了实际的数据类型，类型就会成为封闭类型。封闭类型是可以用来构造实例的。  
如果只传递了部分类型参数，会创建新的开放类型对象。  

至此我们可以明白，CLR根据类型参数为每个泛型创建不同的类型对象，所以在运行时，每个泛型都有自己的具体类型。.NET中的这种实现方式使得泛型是一个纯粹的泛型。

#### 代码爆炸
这是.NET中泛型实现方式的一个缺点。  
使用泛型类型参数的方法，在进行JIT编译时，CLR要为每种不同的方法/类型组合生成本机代码，这种现象成为代码爆炸。  
两个优化：  
CLR只会为一个方法/类型组合编译一次代码。  
CLR认为所有引用类型实参都完全相同，所以代码能够共享。（例如List&lt;String&gt;编译的代码可直接用于List&lt;Stream&gt;的方法，因为它们都是引用类型。乍一看好像会出问题，但是所有引用类型的实参或者变量实际上都是指向堆上对象的指针，而所有对象指针都以相同方式操作）