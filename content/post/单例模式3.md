---
date: 2016-10-27T15:24:20+08:00
status: draft
title: 单例模式3
tags: ["设计模式"]
categories: ["正经的"]
---

### 原来是我们一厢情愿
```csharp
uniqueInstance = new Singleton();
```
问题就出在这么简单的一句代码上，编译器会将我们的代码编译成计算机认识的指令。
我们觉得它应该会这么干：先分配内存；再调用构造器来初始化字段；最后将引用赋值给uniqueInstance。
其实它有可能这么干：先分配内存；将引用赋值给uniqueInstance；最后再调用构造器。
这么搞就出问题了。
如果将引用赋值给uniqueInstance之后调用构造器之前，另一个线程来执行GetSingleton方法，它会发现uniqueInstance不为null，接着开始使用它，但是这时构造函数可能还没执行完呢。
### 最后的实现
```csharp
//解决java和C#中的这两个问题，简单的做法就是用volatile关键字来标记uniqueInstance字段
//恰好c#和java中都是同样的关键字
//其实更好的做法是使用Volatile.Write静态方法，这个之后有讲volatile再详细说
 private volatile static Singleton uniqueInstance;
```
volatile关键字的作用：
* 使uniqueInstance的读取和写入具有“易变性”（保证构造函数在uniqueInstance写入之前结束运行）
* 编译器将不会将字段缓存到CPU寄存器中，所有的读写操作都在RAM中进行

### 更简单的实现
```csharp
    public sealed class Singleton
    {
        //第一次使用该类型的时候，类型构造器被调用创建我们的单实例对象
        private static Singleton uniqueInstance = new Singleton();

        private Singleton() { }

        public static Singleton GetSingleton()
        {
            return uniqueInstance;
        }
    }
```
这种实现方式利用了类型构造器来创建单实例，由于类型构造器只会被调用一次，所以由始至终我们都只会创建一次实例对象。
### 两种实现的优劣
最后，我们来把思路撸一撸。来比较一下这两种实现方式。
类型构造器：当第一次使用到这个类型的时候，单实例对象就会被构造出来，即使我并不打算使用这个对象。
双检锁技术：在真正需要使用到单实例对象的时候才将它初始化出来。如果这个单实例对象大得一逼，非常占用内存，或者不一定准备使用到它，可以考虑使用双检锁技术。