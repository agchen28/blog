---
date: 2016-10-27T15:24:20+08:00
draft: true
title: 单例模式1
tags: ["设计模式"]
categories: ["正经的"]
comments: true
---

### 几句废话
首次写博客，给自己博客的内容与风格定几个要求吧。
这里会记录一些自认为有趣的东西。
关于技术性的内容会尽量以严谨认真的态度来对待，就跟本人一样正经。
文章的篇幅不会太长，太长会吓坏小女生，内容多的话会考虑分篇，希望能够让人一目了然。
### 单例模式（Singleton Pattern）
有翻译成单件或者单态，反正它的特点就是单。比单身狗还单，单身狗经常还会搞搞基。
单例想搞个基都找不到同类，它是一个独一无二的对象。
理解上一般没什么问题，但是实现上就有很多东西可以讲。
### 第一个实现
```csharp
    public sealed class Singleton
    {
        //需要一个额外的Object对象来实现线程同步
        private static Object s_lock = new Object();
        //一个静态字段来引用一个单实例对象
        private static Singleton uniqueInstance;

        //私有构造器，阻止外部任何代码创建实例
        private Singleton() 
        {
            //初始化的代码
         }
        
        //一个全局访问点，返回单实例对象
        public static Singleton GetSingleton()
        {
             //巧妙之处在此：如果对象以及创建，不需要进行线程同步，直接返回
            if (uniqueInstance == null)
            {
                //锁了Object对象，保证同时只有一个线程执行以下代码块
                lock (s_lock)
                {
                    //再次判断，如果还未创建则进行创建
                    if (uniqueInstance == null)
                        uniqueInstance = new Singleton();
                }
            }
            return uniqueInstance;
        }
    }
```
### 几个关键
* 私有的构造函数
* 一个全局访问点GetSingleton
* 还有就是不得不提的双检锁（Double-Check Locking）技术

### 最后
看起来一切都很完美，但是这个实现是有一点问题的。
这样的实现在工作中很常见，因为大多数时候他们需要的并不是一个真正的单例，而且出问题的概率极低，所以即使这么写也不会发现有什么问题。