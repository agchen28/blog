---
date: 2016-12-25T11:11:42+08:00
draft: false
tags: [".NET","Java"]
categories: ["技术相关"]
title: 垃圾回收器
---

### 找到存活的对象

#### 引用计数
这是一种简单但速度很慢的垃圾回收技术。该技术常被用来说明垃圾收集的工作方式，看过介绍Java，JavaScript，.NET中垃圾回收器的实现都提到这个东西。  
给每个对象一个引用计数器，当有引用连接到对象时，计数器加1，当引用离开作用域或者被置为null时，计数器减1。垃圾回收器扫描全部对象，当计数器为0时，释放该对象。  
这种方式有个缺陷，当出现循环引用时，该被释放的对象的引用计数却不为0。

#### 引用跟踪
将所有引用了堆上对象的变量称为根。检查所有活动根，查看它们引用了哪些对象，如果引用了堆上的对象，会继续检查该对象中的根，这样就可以确保所有“活”的对象都被访问到，而且解决了“交互自引用的对象组”的问题。

### 清理

#### 停止-复制（stop-and-copy）
先暂停程序的运行（不属于后台回收模式），将所有存活的对象
复制到新堆并保持紧凑排列。  
这种方式有两个问题：  
一来需要有两个堆，相当于需要多一倍的空间。  
二来当程序运行稳定后，可能只产生少量垃圾，如果仍然复制所有内存显然有点浪费。  

#### 标记-清扫（mark-and-sweep）
根据引用跟踪算法，为所有存活的对象做上标记。当标记工作完成时，清理动作开始，没被标记的对象都将被清理掉。这时堆中的空间是不连续的，所以一般接下来都会有个重新整理的操作。

### 优化方案

#### 自适应
Java虚拟机根据清理效果，如果所有对象都很稳定，垃圾回收器的效率降低的话，就切换到“标记-清扫”模式；同样，根据“标记-清扫”的效果，如果堆中出现很多碎片，就切换回“停止-复制”模式。

#### 分代
CLR和Java中的垃圾回收器都有分代的概念。  
以CLR中的GC为例，介绍一下代的概念。  
垃圾回收器会假设你的代码中（大量研究表明，这些假设对于现今大多数应用程序都是成立的）：  

- 对象越新，生存期越短。  

- 对象越老，生存期越长。

- 回收堆的一部分，速度快于回收整个堆。  

工作原理：  

- CLR的GC支持三代：第0，第1，第2。CLR初始化时为每代选择预算，这个预算会根据垃圾回收效果动态调节。

- 托管堆在初始化时不包含对象，这时添加的对象被称为第0代，垃圾回收器从未检查过它们。

- 根据对第0代的预算容量，如果分配一个新对象造成第0代超过预算，就必须启动一次垃圾回收。垃圾回收后，没有被清理掉的对象升级为第1代，第0代的空间现在是空的。

- 继续在第0代为新的对象分配内存，如果第0代又超出预算，再启动一次垃圾回收。这时，如果第1代没有超出预算就只对第0代进行回收，跟上述一样。如果第1代也超出了预算，垃圾回收器就会检查第0代还有第1代中的所有对象。第1代被回收后存活下来的对象就会升级为第2代，第0代中存活的对象升级为第1代，第0代空间为空。

- 如果一次垃圾回收后，没有回收到足够的内存，会再执行一次完整的回收。如果还是不够，就会抛出OutOfMemoryException异常。
