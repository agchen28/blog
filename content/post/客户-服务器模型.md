---
date: 2017-02-20T09:55:22+08:00
draft: false
tags: ["Node","Go"]
categories: ["技术相关"]
title: "客户-服务器模型"
---

大部分网络应用程序在编写时都假设一端是客户，另一端是服务器，其目的是让服务器为客户提供特定服务。  
一般将这种服务分为两种类型：重复型或并发型。  

- 重复型：  
重复型服务器通过以下步骤进行交互：  
1.等待一个客户请求的到来  
2.处理客户请求  
3.发送响应给客户  
4.返回1步  
重复型服务器的主要问题发生在2步，这时候它不能为其他客户提供服务。 
这种执行模型是同步的，它同时只能处理一个请求，其他的请求都必须按次序等待服务。  
这种服务模型处理能力相当低下，假设处理每个请求消耗的时间为N秒，这类服务的QPS就为1/N。

- 并发型：  
并发型服务器采用以下步骤：  
1.等待一个客户请求的到来  
2.启动一个新的服务器来处理客户的请求。可能生成一个新的进程、线程或者任务，并依赖底层操作系统的支持。生成新的服务器对用户的全部请求进行处理，处理结束后终止这个服务器。  
3.返回1  

## 并发型服务器的实现方式

### 每请求每进程  
为每一个请求都单独创建一个进程来作为服务。  
这种模型的缺点就是代价非常大，内存占用高，进程的创建与销毁时间开销大，而且每台机器所能创建的进程也非常有限。

### 每请求每线程
由于创建进程开销过大，所以引入了多线程模型。  
线程相对于进程来说开销小很多，而且进程之间的每个线程可以共享数据。  
每个线程都有一个独立的线程栈，需要占用一定的内存空间。  
当并发量非常大的时候，会同时创建大量的线程，这样内存占用就上来了。而且还会出现另外一个问题，就是CPU上下文频繁切换的开销。
每个CPU核心在同一时刻只能处理一件事，操作系统通过将CPU切分时间片的方法，让线程可以较为均匀地使用CPU资源。当线程数量过多的时候，进行上下文切换的消耗就会变大。  
这种模型应用的非常广泛，常见的ASP.NET或者Java编写的网络服务一般都属于这种模型。  
这类服务可以采用异步I/O的方式来提升服务器性能。不得不提一下C#的异步编程，它提供的一些语法糖写起来就跟写同步代码差不多，简直太傻瓜化、太爽了。

### 事件驱动
事件驱动这四个字不是很好理解。我把它理解为是为了实现异步I/O的一种处理方式：当执行I/O操作时，绑定一个事件，等I/O操作完成会触发这个事件。（I/O操作包括读写数据库，读写文件，网络请求等一些除CPU计算之外的操作）  
采用这种实现方式的有Node和Nginx，利用单线程来避免高并发下内存开销大和上下文切换频繁的问题。  
不过它是如何利用单线程就能处理大量的请求呢？  
以Node为例来解释一下这个问题。  
考虑到目前的网络服务处理的大部分请求都是跟I/O操作相关，而且I/O操作在整个响应过程中一般是最耗时的。如果采用以往同步I/O的方式，就会阻塞这个线程，必须等I/O操作完才能执行接下来的任务。  
Node的特点包括单线程和异步I/O。其实在单线程的条件下，真正并发执行的是I/O操作。每个请求按次序等待该线程的处理，不过由于异步I/O的特点，每个请求进来触发I/O操作，即使I/O操作还没执行完，该线程也能继续处理其他请求。  
这类服务有个特点就是不处理或者只处理非常少量的CPU计算（这也可以说是它的缺点）。  
假设有一个极端的场景：每个请求都不需要I/O操作，但是都需要比较耗时的CPU计算。那么这类服务就会表现得跟重复型服务一样，每个请求都会阻塞服务。虽然Node可以为每个耗时的CPU计算创建一个子进程，如果为每个请求都创建一个进程就会表现得跟每请求每进程一样。当然这种场景现实中应该不会出现，举这个例子主要还是为了说明它的特点。

### Goroutine
这是之前瞎捣鼓Go的时候接触到的东西。  
Go的出现是为了解决在21世纪多核和网络化环境下越来越复杂的编程问题。  
可能大部分技术人员对Google都会有迷之信仰，谷歌出品，必属精品。  
Go的并发模型理论指导来自于贝尔实验室的Tony Hoare于1978年发表的鲜为外界所知的关于并发研究的基础文献顺序通信进程 （communicating sequential processes） ，缩写为CSP。（看来什么事情都是理论先行啊，就如当年的XX主义。）  
在CSP中，程序是一组中间没有共享状态的平行运行的处理过程，它们之间使用管道进行通信和控制同步。在这样的理论指导下，Go采用Goroutine来实现并行，Goroutine之间通过Channels来通信，而不提倡使用共享数据和锁。  
我们可以借助线程来理解Goroutine。  
每个线程都会分配到一定大小的内存（一般为2M）作为线程栈，这个栈用来存储当前正在调用或者被挂起的函数的内部变量。如果采用每请求每线程的服务，可能大部分的请求都用不了多少的栈空间，这就造成内存的浪费。    
每个Goroutine会分配到一个动态栈，一开始为2KB（应用到网络服务，这可能已经能满足大部分请求所需要的栈空间了）。栈的大小会根据需要动态伸缩，最大可达1GB，虽然一般用不到这么大，但是对于更复杂，更深层次的函数递归调用，可能会需要大一点的栈空间。  
由于创建Goroutine的成本非常低，所以创建成百上千Goroutine是非常普遍的。利用Goroutine来处理请求，既能保证资源充分利用，又不会因为执行CPU计算而阻塞服务。  
关键地方在于Go的运行时包含一个调度器（它决定了Goroutine调度的效率）。它采用m:n调度，表示会在n个操作系统线程上调度m个Goroutine。n通过GOMAXPROCS这个变量来决定，默认为CPU核心数。

就个人愚见，Go的并发模型真的是非常棒，既能保证资源充分利用，又不会因为执行CPU计算而阻塞服务。事件驱动模型虽然能处理很大的并发请求，但是有其局限性。多线程模型目前的问题主要是同步I/O操作长时间阻塞线程，导致创建大量的线程，如果采用异步I/O的方式相信性能方面会提升很多。